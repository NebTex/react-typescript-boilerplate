/**
 * kuper-api
 * The API for the Kuper Proxy Project
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as querystring from "querystring";
import * as url from "url";

import * as isomorphicFetch from "isomorphic-fetch";
import * as assign from "core-js/library/fn/object/assign";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "https://virtserver.swaggerhub.com/criloz/kuper/1.0.0".replace(/\/+$/, '');

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
}

export interface AdminServicePayload {
    "id"?: string;
    "roleId"?: string;
    "logo"?: string;
    "name"?: string;
    "shortDescription"?: string;
    "longDescription"?: string;
    "longDescriptionUrl"?: string;
    "proxyCode"?: string;
    "proxyCodeLanguage"?: number;
    "csrf"?: boolean;
    "impersonateWithinRole"?: boolean;
    "isActive"?: boolean;
    "strategy"?: number;
    "cache"?: AdminServicePayloadCache;
    "cors"?: AdminServicePayloadCors;
    "secretPaths"?: Array<string>;
}

export interface AdminServicePayloadCache {
    "active"?: boolean;
    "ttl"?: number;
}

export interface AdminServicePayloadCors {
    "optionsPassthrough"?: boolean;
    "allowedOrigins"?: Array<string>;
    "maxAge"?: boolean;
    "exposedHeaders"?: Array<string>;
    "allowedHeaders"?: Array<string>;
    "allowedMethods"?: Array<string>;
    "allowCredentials"?: boolean;
}

export interface ClientRole {
    "secretPaths"?: Array<string>;
}

/**
 * a (key, Role) map. `default`is an example key
 */
export interface ClientRoleMap {
    [x: string]: ClientRole;
}

export interface ClientService {
    "id"?: string;
    "logo"?: string;
    "name"?: string;
    "shortDescription"?: string;
    "longDescription"?: string;
    "roles"?: ClientRoleMap;
}

export interface InlineResponse400 {
    "message"?: string;
}

export interface LoginStatus {
    "isLogged"?: boolean;
    "isAdmin"?: boolean;
    "canImpersonate"?: boolean;
    "sessionExpiresAt"?: number;
}



/**
 * AdminApi - fetch parameter creator
 */
export const AdminApiFetchParamCreactor = {
    /** 
     * delete service in role
     * @param roleId role name
     * @param serviceId service unique identifer
     */
    adminDeleteService(params: { roleId: string; serviceId: string; }): FetchArgs {
        // verify required parameter "roleId" is set
        if (params["roleId"] == null) {
            throw new Error("Missing required parameter roleId when calling adminDeleteService");
        }
        // verify required parameter "serviceId" is set
        if (params["serviceId"] == null) {
            throw new Error("Missing required parameter serviceId when calling adminDeleteService");
        }
        const baseUrl = `/v1/api/admin/role/{roleId}/service/{serviceId}`
            .replace(`{${"roleId"}}`, `${params.roleId}`)
            .replace(`{${"serviceId"}}`, `${params.serviceId}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * returns all the available information of the service in {roleId}
     * @param roleId role name
     * @param serviceId service unique identifer
     */
    adminGetService(params: { roleId: string; serviceId: string; }): FetchArgs {
        // verify required parameter "roleId" is set
        if (params["roleId"] == null) {
            throw new Error("Missing required parameter roleId when calling adminGetService");
        }
        // verify required parameter "serviceId" is set
        if (params["serviceId"] == null) {
            throw new Error("Missing required parameter serviceId when calling adminGetService");
        }
        const baseUrl = `/v1/api/admin/role/{roleId}/service/{serviceId}`
            .replace(`{${"roleId"}}`, `${params.roleId}`)
            .replace(`{${"serviceId"}}`, `${params.serviceId}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * create a new service in role
     * @param roleId role name
     * @param serviceId service unique identifer
     * @param body 
     */
    adminSaveService(params: { roleId: string; serviceId: string; body: AdminServicePayload; }): FetchArgs {
        // verify required parameter "roleId" is set
        if (params["roleId"] == null) {
            throw new Error("Missing required parameter roleId when calling adminSaveService");
        }
        // verify required parameter "serviceId" is set
        if (params["serviceId"] == null) {
            throw new Error("Missing required parameter serviceId when calling adminSaveService");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling adminSaveService");
        }
        const baseUrl = `/v1/api/admin/role/{roleId}/service/{serviceId}`
            .replace(`{${"roleId"}}`, `${params.roleId}`)
            .replace(`{${"serviceId"}}`, `${params.serviceId}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "PUT" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * AdminApi - functional programming interface
 */
export const AdminApiFp = {
    /** 
     * delete service in role
     * @param roleId role name
     * @param serviceId service unique identifer
     */
    adminDeleteService(params: { roleId: string; serviceId: string; }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AdminApiFetchParamCreactor.adminDeleteService(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * returns all the available information of the service in {roleId}
     * @param roleId role name
     * @param serviceId service unique identifer
     */
    adminGetService(params: { roleId: string; serviceId: string; }): (fetch: FetchAPI, basePath?: string) => Promise<AdminServicePayload> {
        const fetchArgs = AdminApiFetchParamCreactor.adminGetService(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * create a new service in role
     * @param roleId role name
     * @param serviceId service unique identifer
     * @param body 
     */
    adminSaveService(params: { roleId: string; serviceId: string; body: AdminServicePayload; }): (fetch: FetchAPI, basePath?: string) => Promise<AdminServicePayload> {
        const fetchArgs = AdminApiFetchParamCreactor.adminSaveService(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AdminApi - object-oriented interface
 */
export class AdminApi extends BaseAPI {
    /** 
     * delete service in role
     * @param roleId role name
     * @param serviceId service unique identifer
     */
    adminDeleteService(params: { roleId: string; serviceId: string; }) {
        return AdminApiFp.adminDeleteService(params)(this.fetch, this.basePath);
    }
    /** 
     * returns all the available information of the service in {roleId}
     * @param roleId role name
     * @param serviceId service unique identifer
     */
    adminGetService(params: { roleId: string; serviceId: string; }) {
        return AdminApiFp.adminGetService(params)(this.fetch, this.basePath);
    }
    /** 
     * create a new service in role
     * @param roleId role name
     * @param serviceId service unique identifer
     * @param body 
     */
    adminSaveService(params: { roleId: string; serviceId: string; body: AdminServicePayload; }) {
        return AdminApiFp.adminSaveService(params)(this.fetch, this.basePath);
    }
};

/**
 * AdminApi - factory interface
 */
export const AdminApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * delete service in role
         * @param roleId role name
         * @param serviceId service unique identifer
         */
        adminDeleteService(params: { roleId: string; serviceId: string; }) {
            return AdminApiFp.adminDeleteService(params)(fetch, basePath);
        },
        /** 
         * returns all the available information of the service in {roleId}
         * @param roleId role name
         * @param serviceId service unique identifer
         */
        adminGetService(params: { roleId: string; serviceId: string; }) {
            return AdminApiFp.adminGetService(params)(fetch, basePath);
        },
        /** 
         * create a new service in role
         * @param roleId role name
         * @param serviceId service unique identifer
         * @param body 
         */
        adminSaveService(params: { roleId: string; serviceId: string; body: AdminServicePayload; }) {
            return AdminApiFp.adminSaveService(params)(fetch, basePath);
        },
    }
};


/**
 * AuthApi - fetch parameter creator
 */
export const AuthApiFetchParamCreactor = {
    /** 
     * login using a github token
     * @param token github token
     */
    githubLogin(params: { token: string; }): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            throw new Error("Missing required parameter token when calling githubLogin");
        }
        const baseUrl = `/v1/api/auth/login/github`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["token"]) {
            fetchOptions.body = JSON.stringify(params["token"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * login info
     */
    loginStatus(): FetchArgs {
        const baseUrl = `/v1/api/client/status`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * login off
     */
    logout(): FetchArgs {
        const baseUrl = `/v1/api/auth/kuper/token`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * login using a raw vault token
     * @param token vault token
     */
    tokenLogin(params: { token: string; }): FetchArgs {
        // verify required parameter "token" is set
        if (params["token"] == null) {
            throw new Error("Missing required parameter token when calling tokenLogin");
        }
        const baseUrl = `/v1/api/auth/login/token`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["token"]) {
            fetchOptions.body = JSON.stringify(params["token"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * login using a vault user and password
     * @param username username
     * @param password password
     */
    userPassLogin(params: { username: string; password: string; }): FetchArgs {
        // verify required parameter "username" is set
        if (params["username"] == null) {
            throw new Error("Missing required parameter username when calling userPassLogin");
        }
        // verify required parameter "password" is set
        if (params["password"] == null) {
            throw new Error("Missing required parameter password when calling userPassLogin");
        }
        const baseUrl = `/v1/api/auth/login/userpass/{username}`
            .replace(`{${"username"}}`, `${params.username}`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["password"]) {
            fetchOptions.body = JSON.stringify(params["password"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * AuthApi - functional programming interface
 */
export const AuthApiFp = {
    /** 
     * login using a github token
     * @param token github token
     */
    githubLogin(params: { token: string; }): (fetch: FetchAPI, basePath?: string) => Promise<LoginStatus> {
        const fetchArgs = AuthApiFetchParamCreactor.githubLogin(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * login info
     */
    loginStatus(): (fetch: FetchAPI, basePath?: string) => Promise<LoginStatus> {
        const fetchArgs = AuthApiFetchParamCreactor.loginStatus();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * login off
     */
    logout(): (fetch: FetchAPI, basePath?: string) => Promise<LoginStatus> {
        const fetchArgs = AuthApiFetchParamCreactor.logout();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * login using a raw vault token
     * @param token vault token
     */
    tokenLogin(params: { token: string; }): (fetch: FetchAPI, basePath?: string) => Promise<LoginStatus> {
        const fetchArgs = AuthApiFetchParamCreactor.tokenLogin(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * login using a vault user and password
     * @param username username
     * @param password password
     */
    userPassLogin(params: { username: string; password: string; }): (fetch: FetchAPI, basePath?: string) => Promise<LoginStatus> {
        const fetchArgs = AuthApiFetchParamCreactor.userPassLogin(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AuthApi - object-oriented interface
 */
export class AuthApi extends BaseAPI {
    /** 
     * login using a github token
     * @param token github token
     */
    githubLogin(params: { token: string; }) {
        return AuthApiFp.githubLogin(params)(this.fetch, this.basePath);
    }
    /** 
     * login info
     */
    loginStatus() {
        return AuthApiFp.loginStatus()(this.fetch, this.basePath);
    }
    /** 
     * login off
     */
    logout() {
        return AuthApiFp.logout()(this.fetch, this.basePath);
    }
    /** 
     * login using a raw vault token
     * @param token vault token
     */
    tokenLogin(params: { token: string; }) {
        return AuthApiFp.tokenLogin(params)(this.fetch, this.basePath);
    }
    /** 
     * login using a vault user and password
     * @param username username
     * @param password password
     */
    userPassLogin(params: { username: string; password: string; }) {
        return AuthApiFp.userPassLogin(params)(this.fetch, this.basePath);
    }
};

/**
 * AuthApi - factory interface
 */
export const AuthApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * login using a github token
         * @param token github token
         */
        githubLogin(params: { token: string; }) {
            return AuthApiFp.githubLogin(params)(fetch, basePath);
        },
        /** 
         * login info
         */
        loginStatus() {
            return AuthApiFp.loginStatus()(fetch, basePath);
        },
        /** 
         * login off
         */
        logout() {
            return AuthApiFp.logout()(fetch, basePath);
        },
        /** 
         * login using a raw vault token
         * @param token vault token
         */
        tokenLogin(params: { token: string; }) {
            return AuthApiFp.tokenLogin(params)(fetch, basePath);
        },
        /** 
         * login using a vault user and password
         * @param username username
         * @param password password
         */
        userPassLogin(params: { username: string; password: string; }) {
            return AuthApiFp.userPassLogin(params)(fetch, basePath);
        },
    }
};


/**
 * ClientApi - fetch parameter creator
 */
export const ClientApiFetchParamCreactor = {
    /** 
     * login info
     */
    loginStatus(): FetchArgs {
        const baseUrl = `/v1/api/client/status`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * list availables services
     */
    serviceList(): FetchArgs {
        const baseUrl = `/v1/api/client/services`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * ClientApi - functional programming interface
 */
export const ClientApiFp = {
    /** 
     * login info
     */
    loginStatus(): (fetch: FetchAPI, basePath?: string) => Promise<LoginStatus> {
        const fetchArgs = ClientApiFetchParamCreactor.loginStatus();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * list availables services
     */
    serviceList(): (fetch: FetchAPI, basePath?: string) => Promise<Array<ClientService>> {
        const fetchArgs = ClientApiFetchParamCreactor.serviceList();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ClientApi - object-oriented interface
 */
export class ClientApi extends BaseAPI {
    /** 
     * login info
     */
    loginStatus() {
        return ClientApiFp.loginStatus()(this.fetch, this.basePath);
    }
    /** 
     * list availables services
     */
    serviceList() {
        return ClientApiFp.serviceList()(this.fetch, this.basePath);
    }
};

/**
 * ClientApi - factory interface
 */
export const ClientApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * login info
         */
        loginStatus() {
            return ClientApiFp.loginStatus()(fetch, basePath);
        },
        /** 
         * list availables services
         */
        serviceList() {
            return ClientApiFp.serviceList()(fetch, basePath);
        },
    }
};

